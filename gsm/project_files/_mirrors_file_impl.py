
# ---------------------------------- builtin --------------------------------- #
from typing import Optional
from pathlib import Path

# -------------------------------- third party ------------------------------- #
import msgspec

# ----------------------------------- local ---------------------------------- #
from gsm.project_files._files_impl_utils import GsmFileStruct
import gsm.project_files.files as out
from gsm.log import info, panic
from gsm.version import GSM_VERSION, parse_version, Semver



MIRROR_DIR_PATH = Path(".gsm/mirrors")
MIRRORS_FILE_PATH = MIRROR_DIR_PATH / "mirrors.toml"


class MirrorsFile_Mirror(GsmFileStruct):
    remote: str

    def gen_out(self) -> out.MirrorsFile_Mirror:
        
        # validate before generating
        self.validate()

        info(f"generating definitive mirror from the parse object, mirror: {self.remote}")

        return out.MirrorsFile_Mirror(
            remote=self.remote
        )

    def validate(self):

        info(f"validating mirror: {self.remote}")

        # check if the remote field is not a empty string
        if self.remote == "":
            panic(f"invalid {MIRRORS_FILE_PATH}, internal error or corrupted file, mirror remote is empty, mirror: '{self.remote}'")


class MirrorsFile(GsmFileStruct):
    gsm_version: str
    mirrors: list[MirrorsFile_Mirror]

    def gen_out(self) -> out.MirrorsFile:
        
        # validate before generating
        self.validate()

        info("generating definitive mirrors file from the parse object")
        
        gsm_version_semver = parse_version(self.gsm_version)
        if gsm_version_semver == None:
            panic(f"mirrors file has an invalid version string: {self.gsm_version}, internal error or corrupted file.")

        return out.MirrorsFile(
            gsm_version=gsm_version_semver,
            mirrors=[mirror.gen_out() for mirror in self.mirrors]
        )

    def validate(self):

        info(f"performing mirrors file syntactic validation")

        # since the mirrors file is generated by gsm, we need to check if the gsm version that generated it is compatible with the current gsm version
        # if the versions are not compatible, is not guaranteed that the values hold the same invariants
        file_gsm_version: Semver = version if (version := parse_version(self.gsm_version)) != None else panic(f"mirrors file has an invalid version string: {self.gsm_version}")
        if file_gsm_version.is_compatible_with(GSM_VERSION) == False:
            panic("the mirrors file is not compatible with this version of gsm, clean the project mirrors to generate a new mirror file.")


def load_mirrors_file() -> Optional[out.MirrorsFile]:

    info(f"loading mirrors file: {MIRRORS_FILE_PATH}")

    if not MIRRORS_FILE_PATH.exists():
        info(f"mirrors file does not exist")
        return None

    # check if the mirrors file is a file
    assert MIRRORS_FILE_PATH.is_file(), f"internal error: mirrors file is not a file"

    file_content: str = open(MIRRORS_FILE_PATH, 'r').read()

    try:
        mirrors: MirrorsFile = msgspec.toml.decode(file_content, type=MirrorsFile)
    except msgspec.ValidationError as error:
        panic(f"invalid {MIRRORS_FILE_PATH}, {error}")

    return mirrors.gen_out()
