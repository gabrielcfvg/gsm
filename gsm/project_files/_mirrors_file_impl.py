
# ---------------------------------- builtin --------------------------------- #
from pathlib import Path

# -------------------------------- third party ------------------------------- #
import msgspec

# ----------------------------------- local ---------------------------------- #
from gsm.project_files._files_impl_utils import GsmFileStruct, gen_padding, is_valid_hash
from gsm.log import info, panic
from gsm.version import GSM_VERSION, parse_version, Semver



MIRROR_DIR_PATH = Path(".gsm/mirrors")
MIRRORS_FILE_PATH = MIRROR_DIR_PATH / "mirrors.toml"


class MirrorsFile_Mirror(GsmFileStruct):
    path: str
    hash: str
    remote: str

    def validate(self):

        info(f"validating mirror: {self.path}")

        # we do not need to check if 'path' is a valid path string since any string is a valid path
        # if the string is invalid in any way, the 'Path' constructor would catch it

        # check if the mirror path is relative to the mirrors directory
        assert Path(self.path).is_relative_to(MIRROR_DIR_PATH), f"invalid {MIRRORS_FILE_PATH}, mirror path is not relative to the mirrors directory, mirror: '{self.path}'"

        # check if the mirror path exists and is a file
        assert Path(self.path).is_file(), f"invalid {MIRRORS_FILE_PATH}, mirror path does not exist or is not a file, mirror: '{self.path}'"
        
        # TODO: checar se o nome do arquivo do path tem as extenções corretas

        # check if the hash is a valid hash digest
        assert is_valid_hash(self.hash), f"invalid {MIRRORS_FILE_PATH}, mirror hash is not valid, mirror: '{self.path}', invalid hash: '{self.hash}'"

    def __str__(self, level: int = 0) -> str:
        return gen_padding(level) + f"{self.__class__.__name__}(name={self.path}, remote={self.remote}, hash={self.hash})"

class MirrorsFile(GsmFileStruct):
    gsm_version: str
    mirrors: list[MirrorsFile_Mirror]

    def validate(self):

        info(f"validating mirrors file")

        # since the mirrors file is generated by gsm, we need to check if the gsm version that generated it is compatible with the current gsm version
        # if the versions are not compatible, is not garanteed that the values hold the same invariants
        file_gsm_version: Semver = version if (version := parse_version(self.gsm_version)) != None else panic(f"mirrors file has an invalid version string: {self.gsm_version}")
        if file_gsm_version.is_compatible_with(GSM_VERSION) == False:
            panic("the mirrors file is not compatible with this version of gsm, clean the project mirrors to generate a new mirror file.")

        for mirror in self.mirrors:
            mirror.validate()


    def __str__(self, level: int = 0) -> str:
        
        ret = gen_padding(level) + f"{self.__class__.__name__}()\n"
        for mirror in self.mirrors:
            ret += f"{mirror}\n"
        
        return ret


def load_mirrors_file() -> MirrorsFile:

    info(f"loading mirrors file: {MIRRORS_FILE_PATH}")

    if not MIRRORS_FILE_PATH.exists():
        info(f"mirrors file does not exist")

    # check if the mirros file is a file
    assert MIRRORS_FILE_PATH.is_file(), f"internal error: mirrors file is not a file"

    file_content: str = open(MIRRORS_FILE_PATH, 'r').read()
    mirrors: MirrorsFile = msgspec.toml.decode(file_content, type=MirrorsFile)
    mirrors.validate()

    return mirrors

# TODO: call validade before writing the mirrors file
